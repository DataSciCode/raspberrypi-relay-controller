'use strict';

const Hapi = require('hapi');
const server = new Hapi.Server();
server.connection({ port: 3000 });

const rpio = require('rpio');
const defaultPinOnDuration = 500;

// Raspberry Pi Model B (P1 Header) schematic: http://pi4j.com/images/p1header-large.png
const relayToGpioPinMapping = {
    '1': 11,
    '2': 12
};

// Test: curl -X PUT -D - -H "Content-Type: application/json" -d '{ "relay":{"state":"closed"}}' http://localhost:3000/relays/1
server.route({
    method: 'PUT',
    path: '/relays/{number}',
    handler: function (request, reply) {
        let relayNumber = request.params.number;
        let relay = request.payload.relay;
        if (relay.state === "closed") {
            let relayPin = relayToGpioPinMapping[relayNumber];
            let duration = Number(relay.close_duration || defaultPinOnDuration);
            console.log(JSON.stringify(relay));
            toggleGpioPinOn(relayPin, duration);
        }

        reply().code(204);
    }
});

// Start hapi.js HTTP server
server.start((err) => {
    if (err) {
        throw err;
    }
    console.log(`Server running at: ${server.info.uri}`);
});

// Broadcast API metadata to UDP socket for discovery by other devices
const dgram = require('dgram');
const broadcastSocket = dgram.createSocket("udp4");
const broadcastPort = 41234;
const broadcastAddress = "255.255.255.255";
const broadcastMessage = JSON.stringify({
    source: "{{hostname}} relay API",
    availableRelays: [1,2],
    endpoint: "relays/{relayNumber}",
    endpointMethod: "PUT",
    relayStateClosedObject: { relay: { state: "closed" } }
});
const broadcastIntervalMilliseconds = 60000;
broadcastSocket.bind(() => {
    broadcastSocket.setBroadcast(true);
    setInterval(function (socket) {
        console.log(`Broadcasting API metadata to: ${broadcastAddress}:${broadcastPort}`);
        broadcastSocket.send(broadcastMessage, broadcastPort, broadcastAddress);
    }, broadcastIntervalMilliseconds);
});

function toggleGpioPinOn(pin, durationMilliseconds) {
    // Set the initial state to low.
    rpio.open(pin, rpio.OUTPUT, rpio.LOW);
    // Turn pin ON.
    rpio.write(pin, rpio.HIGH);
    // Wait durationMilliseconds
    rpio.msleep(durationMilliseconds);
    // Turn pin OFF.
    rpio.write(pin, rpio.LOW);
}